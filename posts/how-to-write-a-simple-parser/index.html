<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>怎样写一个简单的Parser（1） | shellfly&#39;s blog</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description"
    content="介绍 🔗作为一个程序员，多少都有听过&quot;paser&quot;、 &ldquo;interpreter&rdquo;、 &ldquo;complier&quot;这些概念，虽然我们可能没有了解过一个编程语言的parser是怎么实现的，但其实日常编程中我们使用过很多种parser，像JSON的parser、YAML的parser，各个语言中都有相应的实现，它们的工作都是把文本字符串转换成某种数据结构。而计算机语言自身的parser也是一样，它的输入是程序员编写的代码，输出也是一个数据结构：“抽象语法树”（AST, Abstract Syntax Tree）。 和JSON parser的不一样的是，AST对程序员来说可能是一个相对陌生的结构，不像JSON数据一样，可以让我们直观的理解。
比如下面这个简单的表达式，经过parser处理后就可以生产一个对应的AST。">
<meta name="generator" content="Hugo 0.138.0">


<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/%20/css/style.css">
<link rel="shortcut icon" href="/%20/images/favicon.ico" type="image/x-icon" />









  </head>

  <body>
    <nav class="navigation">
    
    <a href="/%20/"> <span class="arrow">←</span>Home</a>
    
    <a href="/%20/posts">Archive</a>
    <a href="/%20/tags">Tags</a>
    <a href="/%20/about">About</a>

    

    
</nav>


    <main class="main">
      

<section id="single">
  <h1 class="title">怎样写一个简单的Parser（1）</h1>

  <div class="tip">
    <span>
      Feb 22, 2022 15:14
    </span>
    <span class="split">
      ·
    </span>
    <span>
      
      1976 words
      
    </span>
    <span class="split">
      ·
    </span>
    <span>
      4 minute read
    </span>
  </div>

  <div class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#bnf----描述编程语言语法的语法">BNF &ndash; 描述编程语言语法的语法</a></li>
    <li><a href="#parser的解析过程">Parser的解析过程</a></li>
    <li><a href="#生成器还是手写">生成器还是手写？</a></li>
  </ul>
</nav>
  </div>

  <div class="content">
    <h2 id="介绍">介绍 <a href="#%e4%bb%8b%e7%bb%8d" class="anchor">🔗</a></h2><p>作为一个程序员，多少都有听过&quot;paser&quot;、 &ldquo;interpreter&rdquo;、 &ldquo;complier&quot;这些概念，虽然我们可能没有了解过一个编程语言的parser是怎么实现的，但其实日常编程中我们使用过很多种parser，像JSON的parser、YAML的parser，各个语言中都有相应的实现，它们的工作都是把文本字符串转换成某种数据结构。而计算机语言自身的parser也是一样，它的输入是程序员编写的代码，输出也是一个数据结构：“抽象语法树”（AST, Abstract Syntax Tree）。 和JSON parser的不一样的是，AST对程序员来说可能是一个相对陌生的结构，不像JSON数据一样，可以让我们直观的理解。
比如下面这个简单的表达式，经过parser处理后就可以生产一个对应的AST。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>                             +
</span></span><span style="display:flex;"><span>                 Parser     / \
</span></span><span style="display:flex;"><span> &#34;1 + 2 * 3&#34;    -------&gt;   1   *
</span></span><span style="display:flex;"><span>                              / \
</span></span><span style="display:flex;"><span>                             2   3
</span></span></code></pre></div><p>Python中的ast模块可以用来方便地查看Python代码生成的AST</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Python" data-lang="Python"><span style="display:flex;"><span>In [<span style="color:#666">1</span>]: <span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">ast</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#666">2</span>]: <span style="color:#a2f">print</span>(ast<span style="color:#666">.</span>dump(ast<span style="color:#666">.</span>parse(<span style="color:#b44">&#39;if a&gt;b: c&#39;</span>), indent<span style="color:#666">=</span><span style="color:#666">4</span>))
</span></span><span style="display:flex;"><span>Module(
</span></span><span style="display:flex;"><span>    body<span style="color:#666">=</span>[
</span></span><span style="display:flex;"><span>        If(
</span></span><span style="display:flex;"><span>            test<span style="color:#666">=</span>Compare(
</span></span><span style="display:flex;"><span>                left<span style="color:#666">=</span>Name(<span style="color:#a2f">id</span><span style="color:#666">=</span><span style="color:#b44">&#39;a&#39;</span>, ctx<span style="color:#666">=</span>Load()),
</span></span><span style="display:flex;"><span>                ops<span style="color:#666">=</span>[
</span></span><span style="display:flex;"><span>                    Gt()],
</span></span><span style="display:flex;"><span>                comparators<span style="color:#666">=</span>[
</span></span><span style="display:flex;"><span>                    Name(<span style="color:#a2f">id</span><span style="color:#666">=</span><span style="color:#b44">&#39;b&#39;</span>, ctx<span style="color:#666">=</span>Load())]),
</span></span><span style="display:flex;"><span>            body<span style="color:#666">=</span>[
</span></span><span style="display:flex;"><span>                Expr(
</span></span><span style="display:flex;"><span>                    value<span style="color:#666">=</span>Name(<span style="color:#a2f">id</span><span style="color:#666">=</span><span style="color:#b44">&#39;c&#39;</span>, ctx<span style="color:#666">=</span>Load()))],
</span></span><span style="display:flex;"><span>            orelse<span style="color:#666">=</span>[])],
</span></span><span style="display:flex;"><span>    type_ignores<span style="color:#666">=</span>[])
</span></span></code></pre></div><h2 id="bnf----描述编程语言语法的语法">BNF &ndash; 描述编程语言语法的语法 <a href="#bnf----%e6%8f%8f%e8%bf%b0%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%e8%af%ad%e6%b3%95%e7%9a%84%e8%af%ad%e6%b3%95" class="anchor">🔗</a></h2><p>计算机语言的语法规则通常使用某种上下文无关文法(CFG, Context Free Grammar)的形式语言来描述。最常用的CFG是BNF或者EBNF，BNF最早是John Backus、 Peter Naur 开发用来描述Algol 60语言的，BNF也就是Backus-Naur Form，B和N分别代表他们两个的名字，Form是形式的意思。BNF由一系列规则（更学术的叫法是生成式，Production Rule）组成，比如用来描述类似上面算式&quot;1+2*3&quot;的语法可以被表示为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Expr ::= Factor | Expr &#39;+&#39; Factor
</span></span><span style="display:flex;"><span>Factor ::= Number | Factor &#39;*&#39; Number
</span></span><span style="display:flex;"><span>Number ::= &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39;
</span></span></code></pre></div><p>左边的Expr、Factor和Number都是非终止符，他们要被替换成右边的形式，而<code>+</code>、<code>*</code>，数字<code>1</code>到<code>9</code>都是终止符，终止符不需要再被替换。这样一系列的规则就能够描述一个编程语言涉及到的所有关键字、优先级以及支持的语法。</p>
<p>有了这些规则，我们就可以手写代码来实现一个parser来验证代码是否合法，以及生成AST。计算机科学已经发展了很多年，有很多种成熟的的parser生成器可以拿来用，像是YACC、Bison或者ANTLR等。parser生成器用形式语言描述的规则作为输入，生成一个parser的代码，生成的代码被编译后可以用语言的代码作为输入，输出对应的语法树。</p>
<h2 id="parser的解析过程">Parser的解析过程 <a href="#parser%e7%9a%84%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b" class="anchor">🔗</a></h2><ol>
<li>自顶向下</li>
<li>自底向上</li>
</ol>
<p>Parser的解析过程有两种：自顶向下和自底向上。自顶向下的的过程更符合我们的思维习惯，只需要模拟按照规则从上往下的不断替换就能解析一个语法。自顶向下的最直观的过程就是递归下降（recursive descent），针对每一个规则提供一个递归的解析函数，如果有多种匹配就尝试其中一个，匹配失败再回溯，它是最通用也是最容易理解的方式，所以手写的parser通常都是用的递归下降的方式来实现。</p>
<p>递归下降可能会有效率的问题，会有多层的递归和回溯。另外一种自顶向下的分析方法叫LL(Left-to-right, Left derivation), 通常它也需要提前向后看k个符号，所以LL文法通常用LL(k)表示，常见的就是LL(1).
LL(1)根据规则通过提前创建一个预测的分析表，消除了回溯，在从上往下分析的过程中，通过匹配分析表而不是回溯的尝试所有可能。</p>
<p>LL文法也有它的限制，它能表达的语法有限，相比之下与之对应的自底向上的分析方法LR（Left-to-right, Rightmost derivation)可以表达更丰富的语法，不过LR的parser相对来说也更难以构造，所以LR的parser都是用生成器自动生成的，像Yacc就是基于LALR文法的parser生成器。LL和LR的区别有点像树的前序遍历和后序遍历。</p>
<h2 id="生成器还是手写">生成器还是手写？ <a href="#%e7%94%9f%e6%88%90%e5%99%a8%e8%bf%98%e6%98%af%e6%89%8b%e5%86%99" class="anchor">🔗</a></h2><p>上面提到了实现parser有两种方式：1. 手写，2. parser生成器。虽然生成器很方便，不过并不是所有语言都用生成器来生成parser、解析语法。Python现在用的是<a 
    href="https://devguide.python.org/parser/"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    PEG语法
</a>的生成器来生成parser。<a 
    href="https://rustc-dev-guide.rust-lang.org/the-parser.html"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    Rust
</a>使用的是手写的parser。 Go<a 
    href="https://github.com/golang/go/blob/go1.5/src/cmd/compile/internal/gc/y.go"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    1.6之前
</a>使用的是基于Yacc生成的parser，<a 
    href="https://go-review.googlesource.com/c/go/&#43;/16665/"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    1.6之后
</a>开始改成了手写的parser。Rob Pike给出的<a 
    href="https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d03zx6f/?context=8&amp;depth=9"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    原因
</a>是：1. 不需要维护额外的工具和语言，2. 递归下降的parser可以有更好的错误信息，3. 手写的parser也可以做更多的优化，也就更快。</p>
<p>编程语言为了更好的支持各种语法、性能和友好的错误信息，更多的都会选择手写parser。与之相比SQL的parser一般都是自动生成，不管是<a 
    href="https://github.com/mysql/mysql-server/blob/8.0/sql/sql_yacc.yy"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    MySQL
</a>, <a 
    href="https://github.com/postgres/postgres/blob/REL_13_STABLE/src/backend/parser/gram.y"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    PostgreSQL
</a> 还是<a 
    href="https://github.com/sqlite/sqlite/blob/version-3.36.0/src/parse.y"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    SQLite
</a>都是使用的基于Yacc的自动生成的parser，当然，这也可能跟它们被开发出来的年代有关。</p>
<p>在<a 
    href="https://shellfly.org/posts/how-to-write-a-simple-parser-part2/"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    下一篇文章
</a>中，可以看到如何实际的手写一个简单的parser。</p>
<p>Ref:</p>
<ol>
<li><a 
    href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    BNF
</a></li>
<li><a 
    href="https://en.wikipedia.org/wiki/Parsing"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    Parsing
</a></li>
<li><a 
    href="https://blog.reverberate.org/2013/07/ll-and-lr-parsing-demystified.html"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    LL and LR Parsing Demystified
</a></li>
<li><a 
    href="https://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    Parser generators vs. handwritten parsers: surveying major language implementations in 2021
</a></li>
</ol>

  </div>

  
  <div class="tags">
    
    <a href="https://shellfly.github.io/tags/parser">parser</a>
    
    <a href="https://shellfly.github.io/tags/programming-language">programming language</a>
    
  </div>
  

   
  <div id="comment">
    
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "shellfly" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>


</section>

    </main>
    
    <footer id="footer">
    

    <p class="copyright">
        
        若无特别声明，本网站作品采用<a 
    href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
    
    
     
      target="_blank" 
      rel="noopener"
    
>
    知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议
</a>进行许可。
        
    </p>
    <p class="powerby">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a
            href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

  </body>
</html>
